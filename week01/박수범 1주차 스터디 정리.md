## 자바스크립트와 브라우저, 그리고 DOM (스터디 자료)

### 브라우저 환경과 다양한 명세서: 자바스크립트의 플랫폼

자바스크립트 코드는 단순히 실행되는 것이 아니라, **브라우저**라는 특정 환경에서 돌아간다. 이 환경은 크게 두 가지 표준으로 구성된다.

1.  **ECMAScript (ES)**: 자바스크립트 언어의 **문법과 코어 기능**을 정의하는 명세. `for`, `if`, `const`, `function` 등 우리가 아는 기본적인 문법이 모두 여기에 속한다.
2.  **Web API**: 브라우저가 자바스크립트에게 제공하는 **추가 기능들**. DOM, AJAX (`fetch`), `setTimeout`, Geolocation 등이 모두 Web API에 속한다. `console.log` 또한 Web API 중 하나.

현업에서 중요한 건 **`setTimeout`, `fetch` 같은 비동기 Web API가 어떻게 동작하는지**를 아는 것. 이들은 **자바스크립트 엔진** 외부에서 작동하며, 완료되면 **이벤트 루프**를 통해 콜백 함수를 다시 자바스크립트 엔진의 **콜 스택**으로 보낸다.

-----

### DOM 트리: HTML에 생명 불어넣기

브라우저는 HTML 문서를 읽어 들인 후, 이를 **트리 형태의 객체 구조**로 변환한다. 이것이 바로 **DOM (Document Object Model)**. 모든 HTML 태그는 `Element` 노드, 텍스트는 `Text` 노드, 주석은 `Comment` 노드가 된다. DOM은 단순히 HTML의 복사본이 아니라, 자바스크립트가 HTML의 구조, 내용, 스타일을 동적으로 변경할 수 있게 해주는 **인터페이스**다.

-----

### DOM 탐색하기: 목적에 맞는 효율적인 검색

요소를 찾는 다양한 방법들이 있고, 각각의 특징을 정확히 알아야 한다.

  * `getElementById`, `getElementsByClassName`, `getElementsByTagName`:

      * **장점**: 매우 빠르다. 특히 `getElementById`는 특정 `id` 하나를 바로 찾아오기 때문에 가장 빠름.
      * **단점**: `getElementsBy...` 계열은 \*\*`HTMLCollection`\*\*이라는 **실시간(live) 컬렉션**을 반환한다. 이 컬렉션은 DOM에 변화가 생기면 자동으로 업데이트된다. 예를 들어, `for` 루프를 돌며 요소를 삭제하면 컬렉션의 길이가 변해 인덱스 오류가 발생할 수 있다.

  * `querySelector`, `querySelectorAll`:

      * **장점**: CSS 선택자를 그대로 사용하기 때문에 매우 유연하고 직관적이다.
      * **단점**: 상대적으로 느릴 수 있다.
      * **중요**: \*\*`NodeList`\*\*라는 **정적(static) 컬렉션**을 반환한다. DOM이 변경되어도 `NodeList`는 업데이트되지 않아 안전하게 순회할 수 있다. `NodeList`는 `forEach` 메서드를 지원하지만 `HTMLCollection`은 지원하지 않는다. (최신 브라우저에서는 일부 예외가 있지만 일반적으로 그렇다.)

-----

### 주요 노드 프로퍼티: 노드의 정체성 확인

모든 DOM 노드는 `nodeType`, `nodeName`, `nodeValue`라는 핵심 프로퍼티를 가진다. 이를 통해 노드의 종류를 파악할 수 있다.

  * `nodeType`: 노드의 종류를 나타내는 숫자.
      * `1`: `Element` 노드 (`<p>`, `<div>` 등)
      * `3`: `Text` 노드
      * `8`: `Comment` 노드
  * `nodeName`: 노드의 이름. `p` 요소는 `"P"`, `div` 요소는 `"DIV"`로 반환된다.
  * `nodeValue`: `Text` 노드의 내용. 요소 노드는 `null`을 반환한다.

**`textContent`와 `innerText`의 미묘한 차이**:
`textContent`는 해당 노드와 그 자손 노드의 모든 **텍스트 콘텐츠**를 가져온다. HTML에 작성된 줄바꿈, 공백 등도 모두 포함된다. 반면, `innerText`는 **렌더링된 화면에 보이는 텍스트**만 반환한다. 예를 들어, CSS로 `display: none`이 적용된 요소의 텍스트는 `innerText`로 가져올 수 없다. `innerText`는 레이아웃 엔진을 거치기 때문에 `textContent`보다 성능이 떨어진다.

-----

### 속성과 프로퍼티: HTML과 JS의 연결

DOM 요소는 \*\*속성(attribute)\*\*과 \*\*프로퍼티(property)\*\*라는 두 가지 개념을 갖는다.

  * **속성**: HTML 태그에 직접 정의된 **초기값**. `id`, `class`, `href`, `value` 등이 속성이다. 이들은 HTML 소스 코드에 저장되며, `element.getAttribute()`와 `element.setAttribute()`로 접근한다.
  * **프로퍼티**: 자바스크립트 DOM 객체의 **현재 상태 값**. `element.id`, `element.className`, `element.href`, `element.value` 등.
  * **핵심 차이**: 속성은 변하지 않는 **초기 상태**를 나타내지만, 프로퍼티는 사용자의 상호작용에 따라 변하는 **현재 상태**를 나타낸다. 예를 들어 `<input value="123">`에서 `input.getAttribute('value')`는 항상 `"123"`이지만, `input.value`는 사용자가 입력한 값으로 변한다.

-----

### 문서 수정하기: 성능을 고려한 DOM 조작

대량의 DOM 요소를 추가하거나 삭제할 때 성능 최적화가 중요하다.

  * `innerHTML` / `outerHTML`: 문자열을 통째로 삽입하거나 교체한다. 빠르지만, **XSS 공격**에 취약할 수 있고 기존 요소에 부착된 이벤트 리스너가 모두 사라진다.
  * `createElement` + `appendChild` / `insertBefore` 등: 개별 노드를 만들어 붙이는 방식. 안전하지만, 반복문 내에서 이 작업을 수행하면 DOM에 매번 변화가 생겨 **리플로우와 리페인트**가 자주 발생해 성능이 저하될 수 있다.
  * **성능 최적화 기법**:
      * **`DocumentFragment`**: 보이지 않는 **메모리상의 가상 DOM**이다. 여러 요소를 `DocumentFragment`에 추가한 후, 마지막에 이 `DocumentFragment`를 실제 DOM에 한 번만 `appendChild`하면 **단 한 번의 리플로우**만 발생해 성능을 크게 개선할 수 있다.

-----

### 스타일과 클래스: CSS와 JS의 관심사 분리

* **`element.style`**: 인라인 스타일을 직접 조작합니다. 예: `element.style.color = 'red'`. 여러 속성을 바꿀 때는 `element.style.cssText = 'color: red; font-size: 16px;'`를 사용하면 한 번에 작성 가능합니다. 이 방식은 DOM에 직접 스타일을 추가하기 때문에 브라우저가 매번 **스타일 재계산(Recalculate Style)**을 하고, 경우에 따라 **레이아웃을 다시 배치(Reflow)**하는 비효율적인 과정을 거칠 수 있습니다. 이는 DOM 조작이 성능에 미치는 영향인 **리플로우**와 **리페인트**를 자주 유발합니다.

* **`element.classList`**: 클래스를 추가, 제거, 토글하는 메서드를 제공합니다. 예: `element.classList.add('active')`. 이 방식은 클래스 이름만 변경하고, 스타일 관련 처리는 CSS에 맡깁니다. 따라서 브라우저는 기존에 정의된 CSS 규칙을 한 번만 적용하면 되므로 훨씬 효율적입니다. **JS는 상태(state)를 제어하고, CSS는 그 상태에 따른 스타일을 담당**하는 것이 좋은 설계입니다. 이처럼 관심사를 분리하면 코드의 유지보수성이 높아질 뿐만 아니라, 성능 면에서도 이점을 얻을 수 있습니다. 


-----

### 요소 사이즈와 스크롤: 레이아웃 정보 얻기

  * **요소의 크기**:
      * `clientWidth` / `clientHeight`: 콘텐츠 영역 + **패딩**의 크기. **보더, 스크롤바는 제외**.
      * `offsetWidth` / `offsetHeight`: 콘텐츠 영역 + 패딩 + **보더 + 스크롤바**의 크기.
  * **스크롤**: `scrollWidth`, `scrollHeight`, `scrollTop`, `scrollLeft`.
      * 무한 스크롤 구현 시, `element.scrollTop + element.clientHeight >= element.scrollHeight` 조건으로 스크롤이 끝에 도달했는지 판별할 수 있다.

-----

### 브라우저 창 사이즈와 스크롤: 뷰포트와의 상호작용

  * `window.innerWidth`, `window.innerHeight`: **스크롤바를 포함한** 뷰포트의 크기.
  * `document.documentElement.clientWidth` / `clientHeight`: **스크롤바를 제외한** 뷰포트의 크기.
  * `window.scrollX`, `window.scrollY`: 현재 뷰포트의 **스크롤 위치**를 반환. `document.documentElement.scrollTop / scrollLeft`와 유사하지만 더 범용적으로 사용된다.

-----

### 좌표: 위치 기반 인터랙션 구현

  * **`element.getBoundingClientRect()`**: 해당 요소의 **뷰포트 상대적인** 위치와 크기 정보를 반환하는 메서드. `top`, `left`, `right`, `bottom`, `width`, `height` 속성을 가진다. 스크롤이 되더라도 뷰포트 기준 좌표는 변하지 않아 툴팁 위치 지정, 드래그 앤 드롭 구현에 필수적이다.
  * **`event.pageX` / `event.pageY`**: \*\*문서 전체(document)\*\*를 기준으로 한 마우스 이벤트의 좌표. 스크롤 위치를 포함하므로, 화면 상단에서 아래로 길게 이어진 문서의 경우 스크롤을 내리면 값이 계속 커진다.
  * **`event.clientX` / `event.clientY`**: **뷰포트 기준** 마우스 이벤트의 좌표. 스크롤을 내려도 뷰포트 상에서의 위치는 변하지 않으므로 값이 고정된다.

-----

### 테이블 요소 탐색: 표 내 셀 이동

HTML 테이블의 셀(`<td>`)과 행(`<tr>`)을 자바스크립트로 탐색하는 것은 흔히 발생하는 작업이다. 셀 객체는 부모/자식 관계 외에 **같은 행의 다른 셀**이나 **같은 열의 다른 셀**을 탐색하는 데 유용한 프로퍼티들을 제공한다.

  * **`cellIndex`**: 해당 셀이 속한 행에서 몇 번째 셀인지 인덱스를 반환한다.
  * **`rowIndex`**: 해당 행이 테이블에서 몇 번째 행인지 인덱스를 반환한다.
  * **`rows`**: `<table>` 요소의 프로퍼티로, 테이블 내 모든 `<tr>` 요소를 담고 있는 `HTMLCollection`을 반환한다. `table.rows[rowIndex]`와 같이 특정 행에 접근할 수 있다.
  * **`cells`**: `<tr>` 요소의 프로퍼티로, 해당 행 내 모든 `<td>` 또는 `<th>` 요소를 담고 있는 `HTMLCollection`을 반환한다. `row.cells[cellIndex]`와 같이 특정 셀에 접근할 수 있다.
